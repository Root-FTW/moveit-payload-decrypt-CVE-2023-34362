#!/bin/bash
#MOVEit Payload IV and Key reconstructor given Org Key
 
# Example Usage
 
# First argument is the file containing the payload found in the INSERT/UPDATE sql statement from MOVEit Logs
# this payload should start with @%! followed by the base64.
# Second argument is the Org Key 0 which is found in the affected instance at the registry key Microsoft/Standard Networks/siLock/Institutions/0
# $./ThisScript.sh payload.txt AABBCCDDEEFF1122CCDDEEAA11223344
# Enjoy!
 
 
#Eduardo Duarte
#toorandom@gmail.com
 
if [ "$2" == "" ]
then
  echo "in arg1 you should tell me the base64 filename containing the full payload found in the ISAPI logs, the full payload starts with @%!<..base64..>"
  echo "in arg2 the 16 byte org0 key in hex without spaces which is in the MOVEit server in the registry Microsoft/Standard Networks/siLock/Institutions/0"
  exit 1
fi
 
payload="$1"
org0_key="$2"
#This part of the key is static see line 194 in https://github.com/sfewer-r7/CVE-2023-34362/blob/main/CVE-2023-34362.rb
static_part_key="4083E8338667E61E3056FD9D"

#We cut out the first 3 bytes since are not base64 and it is just a header from the payload
cat $payload | cut -c 4-1000000 | base64 -d > $payload.tmp

#We split the payload in two parts after base64, the header (first 12 bytes) and the encrypted payload
dd if=$payload.tmp of=$payload.header bs=1 count=12 2>/dev/null
dd if=$payload.tmp of=$payload.ciphertext bs=1 skip=12 2>/dev/null
 
# We extract all the header information to build the master key and IV from different parts of the header, also we extract
# the data to verify decryption and if key will be correct
data_sha1=$(xxd -s 2 -l 2  $payload.header  |sed 's/ //g' | cut -d ":" -f 2 | tr '[:lower:]' '[:upper:]' | cut -c 1-4)
org0_key_sha1=$(xxd -s 4 -l 4  $payload.header | sed 's/ //g'  | cut -d ":" -f 2 | tr '[:lower:]' '[:upper:]' | cut -c 1-8)
iv=$(xxd -s 8 -l 4  $payload.header | sed 's/ //g' | cut -d ":" -f 2 | tr '[:lower:]' '[:upper:]' | cut -c 1-8 )
#If is a random 32 bit integer 4 times according to the exploit
iv=$iv$iv$iv$iv
 
masterkey=$static_part_key$org0_key"00000000"
 
echo "[ INFO ]: MasterKey built: $masterkey"
echo "[ INFO ]: Initialization vector: $iv"
echo "[ INFO ]: Part of SHA1 of decrypted $data_sha1"
echo "[ INFO ]: org0 key SHA1 $org0_key_sha1"

# We check that the hash of the OrgKey0 introduced coincides with the payload header information
echo $org0_key | xxd -r -p > $payload.key0
org0_key_sha1_input=$(openssl dgst -sha1 $payload.key0  | awk '{ print $2}' | cut -c 1-8 | tr '[:lower:]' '[:upper:'])

if [ "$org0_key_sha1_input" == "$org0_key_sha1" ]
	then
		echo "[ OK ]: Org Key0's hash coincides with Org Key0's payload's header information :)"
	else
		echo "[ WARN ]: Org Key0 introduced is not correct, decryption is likely going to fail"
fi

#We decrypt the part of the ciphertext
openssl aes-256-cbc -d -in $payload.ciphertext -out $payload.decrypted -iv $iv -K $masterkey 2>/dev/null

# We check that the hash of the decrypted data coincides with the payload header information 
dec_sha1_part=$(openssl dgst -sha1 $payload.decrypted  | awk '{ print $2}' | cut -c 1-4 | tr '[:lower:]' '[:upper:']) 

if [ "$dec_sha1_part" == "$data_sha1" ]
	then
		echo "[ OK ]: Decrypted stream hash coincides with payload header hash"
	else
		echo "[ WARN ]: Decrypted stream does not coincide with the payload header hash"
fi

#We print the decrypted payload contents, both the base64 and the decoded base64

printf "\n"
echo "### BEGIN DECRYPTED ###"
printf "\n"

printf "\n### BEGIN RAW DECRYPT YSOSERIAL OBJECT ###\n"
cat $payload.decrypted | strings
printf "\n### END RAW DECRYPT YSOSERIAL OBJECT ###\n\n"
 
printf "\n### BEGIN YSOSERIAL DECODE ###\n"
cat $payload.decrypted|base64 -d | strings
printf "### END YSOSERIAL DECODE ###\n"
printf "\n\n"
echo "### END DECRYPTED ###"
